## 1. 요구사항 확인

### 1. 소프트웨어 개발방법론

#### 1. 소프트웨어 개발방법론

- 소프트웨어 생명주기 모델 프로세스

  |   프로세스    |                          설명                          |
  | :-----------: | :----------------------------------------------------: |
  | 요구사항 분석 |                    요구, 조건 결정                     |
  |     설계      | 시스템 명세 단계에서 정의 기능 -> <br />수행 방법 결정 |
  |     구현      |                   실제 프로그램 작성                   |
  |    테스트     |                       검사, 평가                       |
  |   유지보수    |                  설치 이후 모든 활동                   |

  

- 소프트웨어 생명주기 모델 종류 : **폭프나반**, 요구 분석 ~ 유지보수 전 공정 체계화 절차

  - 나선형 : **계위개고**

|                종류                 |                             설명                             |
| :---------------------------------: | :----------------------------------------------------------: |
|     **폭**포수 모델 (Waterfall)     | 단계별 -> 선형 순차, 고전적<br />가장 오래됨<br />타당성 검토 -> 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수<br />(+) : 산출물 명확, 관리 편리<br />(-) : 요구사항 변경 hard |
| **프**로토타이핑 모델 (Prototyping) | (+) : 요구 분석 용이, 타당성 검증 가능<br />(-) : 프로토타입 폐기 risk |
|      **나**선형 모델 (Spiral)       | 점진적<br />**계획, 정의 -> 위험 분석 -> 개발 -> 고객 평가**<br />(+) : 위험 감소, 유연한 대처<br />(-) : 단계 반복에 따른 관리 hard |
|     **반**복적 모델 (Iteration)     | 병렬 개발 후 통합<br />(+) : 일정 단축<br />(-) : 관리 비용 증가 |

- 소프트웨어 개발방법론 종류

  |            종류            |                             설명                             |
  | :------------------------: | :----------------------------------------------------------: |
  |       구조적 방법론        |         기능에 따라 나누어 개발<br />분할, 정복 접근         |
  |      정보공학 방법론       | 정보시스템 개발<br />개발주기 -> 대형 프로젝트 수행 => 체계  |
  |      객체지향 방법론       |           복잡한 현실세계 -> 사람이 이해하는 방식            |
  | 컴포넌트 기반 방법론 (CBO) | 컴포넌트 : 소프트웨어 구성<br />-> 조립 후 새로운 응용 프로그램 작성 |
  |       애자일 방법론        | 사람 중심 -> 신속 적응적 경량 개발방법론<br />개발 기간 down, 즉시 피드백, 폭포수와 비교 |
  |      제품 계열 방법론      |        공통 기능 정의, 개발<br />임베디드 소프트웨어         |

- 애자일 모델

  - 유형

    |           유형           |                             설명                             |
    | :----------------------: | :----------------------------------------------------------: |
    | XP (eXtreme Programming) |                 의사소통 개선, 즉각적 피드백                 |
    |          스크럼          | 매일 정해진 시공간, 짧은 시간 개발<br />-> 프로젝트 관리 중심 |
    |            린            |       도요타 린시스템 품질 기법<br />-> 낭비 요소 제거       |

  - 12가지 기본원리

    |        기본원리        |                             설명                             |
    | :--------------------: | :----------------------------------------------------------: |
    |  짝 프로그래밍 (Pair)  |                           두명이서                           |
    |     공동 코드 소유     |                 누구라도 언제든지 수정 가능                  |
    |      지속적 통합       |                   매일 여러 번 통합, 빌드                    |
    |      계획 세우기       | 고객 요구 비즈니스 가치 정의<br />개발자 필요한 것, 지연 부분 알려주기 |
    |      작은 릴리즈       |           작은 시스템 먼저 -> 짧은 단위로 업데이트           |
    |        메타포어        | 공통 이름 체계, 시스템 서술서<br />-> 고객 ~ 개발자 간 의사소통 원활 |
    |     간단한 디자인      |        현재 요구사항에 적합한 가장 단순한 시스템 설계        |
    | 테스트 기반 개발 (TDD) |          테스트를 먼저 수행 -> 통과하도록 코드 작성          |
    |        리팩토링        | 기능을 바꾸지 않으면서<br />중복제거, 단순화를 위해 시스템 재구성 |
    |      40시간 작업       |                      일주일 40시간 노동                      |
    |       고객 상주        | 개발자의 질문에 즉각 대답 가능한 고객<br />-> 프로젝트에 풀타임 상주 필요 |
    |       코드 표준        |                     코딩 표준 정의 필요                      |

#### 2. 비용산정, 일정관리 모형

- 델파이 기법 : 전문가의 경험적 지식을 통한 문제 해결, 미래 예측

- 비용산정 모형 종류

  |                  모형                  |                             설명                             |
  | :------------------------------------: | :----------------------------------------------------------: |
  |          LoC (Lines of Code)           | 원시 코드 라인 수의 낙관, 중간, 비관 측정<br />-> 예측치 => 비용 산정 |
  |               Man Month                |     한 사람이 1개월 동안 할 수 있는 일의 양 -> 비용 산정     |
  | COCOMO <br />(COnstructive COst MOdel) |                  프로그램 규모 -> 비용 산정                  |
  |            푸트남 (Putnam)             |      개발주기 단계별로 요구 인력 분포 가정 -> 비용 산정      |
  |             기능점수 (FP)              | 요구 기능을 증가시키는 인자별로 가중치<br />요인별 가중치 합산 후 총 기능 점수 계산 -> 비용 산정 |

- 일정관리 모델 종류

  |                           모델                           |                       설명                        |
  | :------------------------------------------------------: | :-----------------------------------------------: |
  |                     주 공정법 (CPM)                      |        작업 수행 순서 얽혀 있는 일정 계산         |
  | PERT<br />(Program Evaluation<br />and Review Technique) |          비관, 중간, 낙관치 3점 추정방식          |
  |              중요 연쇄 프로젝트 관리 (CCPM)              | 주 공정 연소법 -> 자원제약사항 고려하여 일정 작성 |

  - 주 공정법 (CPM : Critical Path Method) : 종료까지 가장 긴 시간이 걸리는 경로 계산

### 2. 현행 시스템 분석

#### 1. 현행 시스템 파악

- 소프트웨어 아키텍처 4+1 뷰 : **유논프구배**

  |     뷰     |                             설명                             |
  | :--------: | :----------------------------------------------------------: |
  | 유스케이스 | 유스케이스, 아키텍쳐 도출<br />다른 뷰 검증<br />사용자, 설계자, 개발자, 테스트 관점 |
  |    논리    |    기능 요구사항 제공 방식 설명<br />설계자, 개발자 관점     |
  |  프로세스  | 비기능적 속성<br />자원 효율적 사용, 병행 실행, 비동기, 이벤트 처리<br />개발자, 시스템 통합자 관점 |
  |    구현    |     정적 소프트웨어 모듈 구성<br />컴포넌트 구조, 의존성     |
  |    배포    |         컴포넌트가 물리 아키텍처에 배치 구조를 매핑          |

- 소프트웨어 아키텍처 평가 모델 : **SACAA**

  |                          모델                           |                             설명                             |
  | :-----------------------------------------------------: | :----------------------------------------------------------: |
  | SAAM<br />(Software Architecture<br />Analysis Method)  | 변경 용이, 기능성 집중<br />평가 용이 -> 경험 없어도 활용 가능 |
  | ATAM<br />(Architecture Trade-Off<br />Analysis Method) | 아키텍처 품질 속성 만족하는지<br />품질 속성의 이해 상충 관계까지 평가 |
  |      CBAM<br />(Cost Benefit<br />Analysis Method)      | ATAM 바탕 시스템 아키텍처 분석<br />경제적 의사결정 요구 충족 |
  |             ADR<br />(Active Design Review)             |         소프트웨어 아키텍처 구성요소 간 응집도 평가          |
  | ARID<br />(Active Review for<br />Intermediate Designs) |                   특정 부분 품질요소 집중                    |

- 디자인 패턴 구성요소 : **패문솔 사결샘**

  - 패턴의 이름, 문제 및 배경, 솔루션, 사례, 결과, 샘플 코드

- 디자인 패턴 유형 : **생구행**

  - 생성, 구조, 행위

  - 생성 : **빌프로 팩앱싱**

    |       패턴       |               설명                |
    | :--------------: | :-------------------------------: |
    |     Builder      | 생성, 표기 분리 -> 복잡 개체 생성 |
    |    Prototype     |          기존 객체 복제           |
    |  Factory Method  |  클래스 국한하지 않고 객체 생성   |
    | Abstract Factory |   동일한 주제 다른 팩토리 묶음    |
    |    Singleton     |       한 클래스에 한 객체만       |

  - 구조 : **브데 퍼플 프록 컴 어**

    |   패턴    |                             설명                             |
    | :-------: | :----------------------------------------------------------: |
    |  Bridge   |                 구현 + 추상화 부분까지 변경                  |
    | Decorator |           객체 결합 -> 기능 동적으로 유연하게 확장           |
    |  Facade   |                     통합 인터페이스 제공                     |
    | Flyweight |          여러 개 가상 인스턴스 제공 -> 메모리 절감           |
    |   Proxy   |                     특정 객체 접근 제어                      |
    | Composite |                  복합, 단일 객체 동일 취급                   |
    |  Adapter  | 호환 X 클래스 함께 이용하도록<br />-> 타 클래스 인터페이스 기존 인터페이스에 덧씌움 |

  - 행위 : **미인이 템옵 스테 비커 스터트 메체**

    |          패턴          |                           설명                            |
    | :--------------------: | :-------------------------------------------------------: |
    |        Mediator        |                  상호작용 유연 변경 지원                  |
    |      Interpreter       |                     문법 자체 캡슐화                      |
    |        Iterator        |   내부구조 노출 없이 복잡객체 순차적으로 접근 가능하게    |
    |    Template Method     | 상위 작업 구조 바꾸지 않으면서 서브 클래스 작업 일부 수행 |
    |        Observer        |  객체 상태 변화에 따라 다른 객체 상태 연동, 일대다 의존   |
    |         State          |               객체 상태 따라 행위 내용 변경               |
    |        Visitor         |      복합 객체 원소 특성에 따라 동작 수행하도록 지원      |
    |        Command         |                  요구사항 객체로 캡슐화                   |
    |        Strategy        |  행위 객체 클래스로 캡슐화, 동적으로 행위 자유롭게 변환   |
    |        Memento         |      객체 이전으로 복구 필요 시 작업취소 (Undo) 요청      |
    | Chain of Reponsibility |              한 요청 2개 이상 객체에서 처리               |

- 분석 산출물 : **현기인 아소하네**

  - 정보시스템 구성 현황, 정보시스템 기능 구성도, 인터페이스 현황, 현행 시스템 아키텍처 구성도, 소프트웨어 구성도
  - 하드웨어 구성도, 네트워크 구성도

- 