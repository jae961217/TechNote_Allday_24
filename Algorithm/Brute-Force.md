# 완전 탐색 (Brute Force)

> 가능한 경우의 수를 **모두** 검사해보는 탐색 방법

> 일반적으로 비효율적인 시간 복잡도를 가지고 있으므로, 전체 데이터의 갯수가 **100만 개 이하**일 때 주로 사용한다.





## 1. 반복/조건문을 통해 가능한 모든 방법 찾기

<br>

- ex) 00시 00분 00초 ~ 23시 59분 59초 에서 '3'이 들어가는 시간 탐색하기

  ```python
  count = 0
  for i in range(23 +1):
      for j in range(59 +1):
          for k in range(59 +1):
              # 매 시각 문자열에 '3'이 포함되어 있으면 카운트 증가
              if '3' in str(i) + str(j) + str(k):
                  count += 1
                  print(f'{i}시 {j}분 {k}초')
          print()
      print()
  print(count)
  ```

  > 3중 반복문이지만, 하루가 86,400초, 즉 최대 경우의 수가 100,000 이하이므로 완전 탐색으로 해결 가능

<br>

## 2. 순열 (Permutation)

1. 반복문을 통한 순열 생성

   ```python
   # 반복문을 통한 순열 생성
   arr = [1, 2, 3]
   
   for p1 in arr:
       for p2 in arr:
           if p1 != p2:
               for p3 in arr:
                   if p1 != p3 and p2 != p3:
                       print(f'[{p1}, {p2}, {p3}]')
   
   # [1, 2, 3]
   # [1, 3, 2]
   # [2, 1, 3]
   # [2, 3, 1]
   # [3, 1, 2]
   # [3, 2, 1]
   ```

   > arr 원소의 갯수 중 3개를 고르는 순열을 생성하므로, 3중 반복문으로 구현한다.

   > 반복문의 내부에서 조건문을 통해 각각 p1으로 사용하지 않은 수, p1, p2에서 사용하지 않은 수에 대해서만 순열을 생성할 수 있다.

   > arr의 원소 p1, p2, p3에 대한 반복문이므로, 원소 갯수가 정해지지 않은 경우에는 사용하기 어렵다.

   <br>

2. 재귀호출을 통한 순열 생성

   ```python
   def permutation(n, idx):
       # 종료 조건: 
       if idx == n:
           print(arr)
           return
       else:
           for i in range(idx, n):
               arr[idx], arr[i] = arr[i], arr[idx]
               permutation(n, idx+1)
               arr[idx], arr[i] = arr[i], arr[idx]
   
   arr = [1, 2, 3]
   permutation(len(arr), 0)
   # [1, 2, 3]
   # [1, 3, 2]
   # [2, 1, 3]
   # [2, 3, 1]
   # [3, 2, 1]
   # [3, 1, 2]
   ```

   > 함수 안에서 자기자신을 호출하는 재귀호출 방식에서 종료조건을 작성하지 않는 경우, 최대 재귀 깊이(maximum recursion depth) 에러가 발생할 수 있다.

<br>

## 3. 비트마스크(Bitmask)

> 비트(bit)연산을 통해 부분집합을 표현하는 방법

> AND 연산(&) : 둘 다 1인 경우(1&1)에만 1
> OR 연산(|) : 둘 중 1개만 1인 경우(1|0, 0|1)에 1
> NOT 연산(~) : 1이면 0, 0이면 1
> XOR 연산(^) : 둘의 관계가 다르면(1 XOR 0, 0 XOR 1) 1, 같으면(1 XOR 1, 0 XOR 0) 0
> Shift 연산(<<, >>) : A << B는 A를 좌측으로 B 비트만큼 밂

> |  A   |  B   | A&B  | A\|B |  ~A  | A^B  |
> | :--: | :--: | :--: | :--: | :--: | :--: |
> |  0   |  0   |  0   |  0   |  1   |  0   |
> |  0   |  1   |  0   |  1   |  1   |  1   |
> |  1   |  0   |  0   |  1   |  0   |  1   |
> |  1   |  1   |  1   |  1   |  0   |  0   |

> ex) 10진수에 대한 **1 << 3**의 경우, 1의 2진수 **1** 을 3칸 좌측으로 민 값, 2진수 **1000**으로 계산된다.



- 비트마스크를 통한 부분집합 완전탐색

  ```python
  arr = [1, 2, 3]
  n = len(arr)
  
  for i in range(0, (1<<n)):  # 1<<n: 부분집합의 갯수
      for j in range(0, n):   # 원소의 수만큼 비트를 비교
          if i & (1<<j):     # i의 j번째 비트가 1이면, j번째 원소를 출력
              print(arr[j], end= ' ')
      print()
  # 1 
  # 2
  # 1 2
  # 3
  # 1 3
  # 2 3
  # 1 2 3
  ```

  